name: "Prepare Command Tool"
description: "Downloads a previously built artifact or executes a local fallback build to ensure the command tool is ready for use."
inputs:
  github-token:
    description: "GitHub token for API access and Artifact downloads."
    required: true
runs:
  using: "composite"
  steps:
    - name: Set up variables
      id: setup_vars
      shell: bash
      run: |
        COMMAND_TOOL="scripts/command/command.bin"

        echo "workflow_file=build-make-command.yaml" >> $GITHUB_OUTPUT
        echo "artifact_name=make-command-tool" >> $GITHUB_OUTPUT
        echo "artifact_path=$(dirname ${COMMAND_TOOL})" >> $GITHUB_OUTPUT
        echo "command_tool=${COMMAND_TOOL}" >> $GITHUB_OUTPUT

    - name: Set up necessary tools
      shell: bash
      run: |
        # Ensure gh CLI and jq are available (they are usually available in GitHub hosted runners)
        gh version
        jq --version

    - name: Find Latest Build Run ID
      id: find_run
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        BLUE='\033[0;34m'
        YELLOW='\033[0;33m'
        GREEN='\033[0;32m'
        GRAY='\033[0;90m'
        RED='\033[0;31m'
        RESET='\033[0m'

        workflow_file=${{ steps.setup_vars.outputs.workflow_file }}
        # 1. List all workflows to find the correct filename
        all_workflows=$(gh api \
          --header 'Accept: application/vnd.github.v3+json' \
          /repos/${{ github.repository }}/actions/workflows \
          --jq '.workflows[] | .path' 2>&1)

        if [[ $? -ne 0 ]]; then
          printf "${YELLOW}‚ö†Ô∏è Could not list workflows. Error: ${all_workflows}${RESET}\n"
          printf "${YELLOW}‚ö†Ô∏è Will build command tool locally as fallback${RESET}\n"
          echo "run_id=''" >> $GITHUB_OUTPUT
          exit 0
        fi

        printf "${GRAY}Available workflows:${RESET}\n${all_workflows}\n"

        # 2. Check for in_progress runs
        in_progress_resp=$(gh api \
          --header 'Accept: application/vnd.github.v3+json' \
          "/repos/${{ github.repository }}/actions/workflows/${workflow_file}/runs?status=in_progress" \
          2>&1 || true)
        in_progress=$(echo "${in_progress_resp}" | jq '.workflow_runs | length' 2>/dev/null || echo "0")

        # 3. Check for queued runs
        queued_resp=$(gh api \
          --header 'Accept: application/vnd.github.v3+json' \
          "/repos/${{ github.repository }}/actions/workflows/${workflow_file}/runs?status=queued" \
          2>&1 || true)
        queued=$(echo "$queued_resp" | jq '.workflow_runs | length' 2>/dev/null || echo "0")

        ACTIVE_RUNS=$((in_progress + queued))

        if [[ "$ACTIVE_RUNS" -gt 0 ]]; then
            echo "::warning Found $ACTIVE_RUNS active builds. Using latest successful artifact."
        fi

        # 4. Get successful run
        success_resp=$(gh api \
          --header 'Accept: application/vnd.github.v3+json' \
          "/repos/${{ github.repository }}/actions/workflows/${workflow_file}/runs?status=success" \
          2>&1 || true)

        if echo "${success_resp}" | grep -q '"message": "Not Found"'; then
           printf "${YELLOW}‚ö†Ô∏è Workflow file path incorrect or repo not found (404).${RESET}\n"
           printf "${GRAY}Response: ${success_resp}${RESET}\n"
           echo "run_id=" >> $GITHUB_OUTPUT
           exit 0
        fi

        run_id=$(echo "${success_resp}" | jq -r '.workflow_runs[0].id // empty' 2>/dev/null)
        printf "${GREEN}run_id raw value: '${run_id}'${RESET}\n"

        if [[ -z "${run_id}" || "${run_id}" == "null" ]]; then
            echo "::warning title=Artifact Search::API returned 0 successful runs. Will build locally."
            echo "run_id=" >> $GITHUB_OUTPUT
        else
            echo "::notice title=Artifact Search::Found latest successful build run ID: ${run_id}"
            echo "run_id=${run_id}" >> $GITHUB_OUTPUT
        fi

    - name: ‚¨áÔ∏è Download Command Tool artifact
      id: download_artifact
      uses: actions/download-artifact@v4
      if: steps.find_run.outputs.run_id != ''
      with:
        name: ${{ steps.setup_vars.outputs.artifact_name }}
        path: ${{ steps.setup_vars.outputs.artifact_path }}
        run-id: ${{ steps.find_run.outputs.run_id }}
        github-token: ${{ inputs.github-token }}
      continue-on-error: true

    - name: Check if binary exists and set permissions
      id: check_binary
      shell: bash
      run: |
        GREEN="\033[1;32m"
        YELLOW="\033[1;33m"
        RESET="\033[0m"

        command_tool="${{ steps.setup_vars.outputs.command_tool }}"
        if [ -f "${command_tool}" ]; then
          chmod +x "${command_tool}"
          printf "${GREEN}‚úÖ Binary found and permissions set${RESET}\n"
          ls -lh "${command_tool}"
          echo "binary_exists=true" >> $GITHUB_OUTPUT
        else
          printf "${YELLOW}‚ö†Ô∏è Binary not found at ${command_tool}${RESET}\n"
          echo "binary_exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Install uv
      if: steps.check_binary.outputs.binary_exists != 'true'
      uses: astral-sh/setup-uv@v6
      with:
        enable-cache: true

    - name: üõ†Ô∏è Fallback - Build command tool locally
      id: fallback_build
      if: steps.check_binary.outputs.binary_exists != 'true'
      shell: bash
      run: |
        echo "::warning title=Local Build::Building command tool locally as fallback..."
        make build-make-command
        ls -lh "${{ steps.setup_vars.outputs.command_tool }}"
